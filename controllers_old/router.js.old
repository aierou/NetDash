const exports = module.exports;

const request = require('request');
const crypto = require('crypto');
const config = require('../config.js');
const logger = require('../utilities/logger.js');

const url = 'http://192.168.0.1';
const cookies = request.jar();
const baseHeaders = {
  Referer: `${url}/logon/logon.htm`, // just need some "valid" referer
};
let hostnames = [];
let trafficStats = [];
let throttled = [];
const THROTTLE_THRESHOLD_UP = 200 * 1000; // Bytes
const THROTTLE_THRESHOLD_DOWN = 2000 * 1000;
const THROTTLE_ID_OFFSET = 3;
const THROTTLE_TIMEOUT_CYCLES = 30;
const THROTTLE_MAX_TIMEOUT = 600;
const MAX_BANDWIDTH = 6 * 1000 * 1000;
const LIST_THROTTLE_UP = -1;
const LIST_THROTTLE_DOWN = -2;
const LIST_THROTTLE_BOTH = -3;
const LIST_CRITICAL = -4;
const CRITICAL_MODE_DURATION = 300 * 1000;

function init() {
  setInterval(update, 2000);
  setInterval(lazyUpdate, 60000);

  logIn(() => {
    // Reset throttling groups
    exports.clearGroups();

    getDHCPClients();
  });
}

function update() {
  getTraffic();
  manageTraffic();
}

function lazyUpdate() {
  getDHCPClients();
}

let lastThrottleDown = '';
let lastThrottleUp = '';
let lastThrottleBoth = '';
function manageTraffic() {
  if (trafficStats.length <= 1 || criticalMode) return;
  // Check that we match conditions for throttling (May need to modify math a bit)
  // None of this is going to be scientific; I'm just trying to find comfortable values.
  let totalBandwidth = 0;
  let using = 0;
  for (var i = 0; i < trafficStats.length; i++) {
    let bandwidth = Number(trafficStats[i][1]) / 5;
    bandwidth += Number(trafficStats[i][2]) / 5;
    totalBandwidth += bandwidth;
    if (bandwidth > 0) using++;
  }
  let heavyusing = 0;
  for (var i = 0; i < trafficStats.length; i++) {
    let used = Number(trafficStats[i][1]) / 5;
    used += Number(trafficStats[i][2]) / 5;
    used /= totalBandwidth;
    if (used >= (1 / using)) {
      heavyusing++;
    }
  }
  const throttle = totalBandwidth > MAX_BANDWIDTH / heavyusing && heavyusing > 2;

  const throttled_buffer = [];
  for (var i = 0; i < trafficStats.length; i++) {
    // Add throttled users
    const ip = trafficStats[i][0];
    var down = trafficStats[i][1] / 5;
    var up = trafficStats[i][2] / 5;
    var id = parseInt(ip.split('.')[3], 10) - THROTTLE_ID_OFFSET;
    if (id > 50 - THROTTLE_ID_OFFSET) continue; // Unsupported ip (router limit)
    if (id == 1) continue; // Not throttling myself lul (in the future make priority lists)
    const entry = throttled.find(a => a.id == id) || {
      id, lists: [], timeout: 0, ip,
    };
    if (down > THROTTLE_THRESHOLD_DOWN && throttle) {
      entry.timeout += THROTTLE_TIMEOUT_CYCLES;
      if (!entry.lists.includes(LIST_THROTTLE_DOWN)) { entry.lists.push(LIST_THROTTLE_DOWN); }
    }
    if (up > THROTTLE_THRESHOLD_UP && throttle) {
      entry.timeout += THROTTLE_TIMEOUT_CYCLES;
      if (!entry.lists.includes(LIST_THROTTLE_UP)) { entry.lists.push(LIST_THROTTLE_UP); }
    }
    if (down < THROTTLE_THRESHOLD_DOWN / 2 && entry.lists.includes(LIST_THROTTLE_DOWN)) {
      entry.timeout--;
      if (entry.timeout <= 0) {
        var index = entry.lists.indexOf(LIST_THROTTLE_DOWN);
        if (index != -1) { entry.lists.splice(index, 1); }
      }
    }
    if (up < THROTTLE_THRESHOLD_UP / 2 && entry.lists.includes(LIST_THROTTLE_UP)) {
      entry.timeout--;
      if (entry.timeout <= 0) {
        var index = entry.lists.indexOf(LIST_THROTTLE_UP);
        if (index != -1) { entry.lists.splice(index, 1); }
      }
    }
    entry.timeout = Math.min(Math.max(entry.timeout, 0), THROTTLE_MAX_TIMEOUT);
    if (entry.lists.length != 0) { throttled_buffer.push(entry); }
  }
  throttled = throttled_buffer;
  // Generating the user lists.
  const throttleUpUsers = [];
  const throttleDownUsers = [];
  const throttleBothUsers = [];
  for (var i = 0; i < throttled.length; i++) {
    var up = throttled[i].lists.includes(LIST_THROTTLE_UP);
    var down = throttled[i].lists.includes(LIST_THROTTLE_DOWN);
    if (up && down) {
      throttleBothUsers.push(throttled[i].id);
    } else if (up) {
      throttleUpUsers.push(throttled[i].id);
    } else if (down) {
      throttleDownUsers.push(throttled[i].id);
    }
  }
  const throttleUp = throttleUpUsers.join(',');
  const throttleDown = throttleDownUsers.join(',');
  const throttleBoth = throttleBothUsers.join(',');

  // Finally make the request to the server
  if (throttleUp != lastThrottleUp) setGroup(LIST_THROTTLE_UP, throttleUp);
  if (throttleDown != lastThrottleDown) setGroup(LIST_THROTTLE_DOWN, throttleDown);
  if (throttleBoth != lastThrottleBoth) setGroup(LIST_THROTTLE_BOTH, throttleBoth);

  lastThrottleUp = throttleUp;
  lastThrottleDown = throttleDown;
  lastThrottleBoth = throttleBoth;
}

let criticalTimer;
var criticalMode = false;
exports.criticalMode = function () {
  logger.log('Entering critical mode.');
  criticalMode = true;
  exports.clearGroups(true);
  criticalTimer = setTimeout(() => {
    logger.log('Exiting critical mode.');
    criticalMode = false;
    setGroup(LIST_CRITICAL, '');
  }, CRITICAL_MODE_DURATION);
  const list = [...Array(47).keys()].map(x => x += 1);
  // TODO: Handle this with priority list
  list.splice(0, 1); // me
  setGroup(LIST_CRITICAL, list.join(','));
};

exports.clearGroups = function (critical) {
  setGroup(LIST_THROTTLE_UP, '');
  setGroup(LIST_THROTTLE_DOWN, '');
  setGroup(LIST_THROTTLE_BOTH, '');
  if (!critical) setGroup(LIST_CRITICAL, ''); // Ideal solution here would be a request queue
  lastThrottleDown = '';
  lastThrottleUp = '';
  lastThrottleBoth = '';
  clearTimeout(criticalTimer);
};

function setGroup(group, list) {
  if (list == '') list = 'NULL';
  logger.log(`Group set ${group}: ${list}`);
  const formData = {
    rd_view: 1,
    slt_user: 0,
    slt_group: group,
    selectgroup2: '',
    selectuser2: list,
    slt_user2: '',
    slt_group2: group,
  };
  request.post({
    url: `${url}/userRpm/Ugm_View.htm`, form: formData, followAllRedirects: true, jar: cookies, headers: baseHeaders,
  }, (err, res, body) => {
    if (err) console.log(err);
    // This seems to be the only variable (outside of parsing html) that identifies a logout
    if (res.headers['set-cookie']) {
      logIn(setGroup, [group, list]);
    }
  });
}

function logIn(callback, cbparams) {
  logger.log('Logging into router');
  request.get({ url, followAllRedirects: true, jar: cookies }, (err, res, body) => {
    // Lol what the hell is this (how the client sends the password)
    const cs = cookies.getCookieString(url).split('=')[1];
    const tmp_pass = crypto.createHash('md5').update(config.router.password).digest('hex');
    const hash = crypto.createHash('md5').update(`${tmp_pass.toUpperCase()}:${cs}`).digest('hex');
    const encoded = `${config.router.username}:${hash.toUpperCase()}`;
    const formData = {
      encoded,
      nonce: cs,
      URL: '../logon/loginJump.htm',
    };
    request.post({
      url: `${url}/logon/loginJump.htm`, form: formData, followAllRedirects: true, jar: cookies, headers: baseHeaders,
    }, (err, res, body) => {
      // This request is necessary to kick out someone who is already logged-in to the router. Always sending it is harmless.
      request.get({
        url: `${url}/logon/loginConfirm.htm`, followAllRedirects: true, jar: cookies, headers: baseHeaders,
      }, (err, res, body) => {
        callback.apply(callback, cbparams);
      });
    });
  });
}

function getDHCPClients() {
  request.get({
    url: `${url}/userRpm/DhcpServer_ClientList.htm?slt_interface=0`, followAllRedirects: true, jar: cookies, headers: baseHeaders,
  }, (err, res, body) => {
    if (err) {
      console.log(err);
      return;
    }
    // This seems to be the only variable (outside of parsing html) that identifies a logout
    if (res.headers['set-cookie']) {
      logIn(getDHCPClients);
      return;
    }

    var i = body.indexOf('var dhcpList = new Array(');
    i += 'var dhcpList = new Array('.length;
    const j = body.indexOf('0,0 );\n</script>\n<script language=JavaScript>\nvar dhcpPara = new Array(');
    nums = body.substring(i, j);
    nums = nums.split('"').join('').split('\n').join(''); // replace all the extra formatting nonsense

    const values = nums.split(',');
    const clients = new Array();
    const len = Math.floor(values.length / 4) * 4;
    for (var i = 0; i < len; i += 4) {
      const index = i / 4;
      clients[index] = {};
      clients[index].hostname = values[i];
      // clients[index].mac = values[i+2]; // Don't really care about mac address
      clients[index].ip = values[i + 2];
    }
    hostnames = clients;
  });
}

function getTraffic() {
  request.get({
    url: `${url}/userRpm/System_Statics.htm?btn_refresh=btn_refresh&comindex=9&direct=1&interface=1`, followAllRedirects: true, jar: cookies, headers: baseHeaders,
  }, (err, res, body) => {
    if (err) {
      return console.log(err);
    }
    // This seems to be the only variable (outside of parsing html) that identifies a logout
    if (res.headers['set-cookie']) {
      logIn(getTraffic);
      return;
    }
    // Now we get to parse html. Yaaaay
    var i = body.indexOf('var staEntryInf = new Array(');
    i += 'var staEntryInf = new Array('.length;
    const j = body.indexOf(');\n</script>\n</HEAD>');
    nums = body.substring(i, j);
    nums = nums.split('"').join('').split('\n').join(''); // replace all the extra formatting nonsense
    // Now we need to parse the data into something useful
    const values = nums.split(',');
    const statistics = new Array();
    const len = Math.floor(values.length / 10) * 10;
    for (var i = 0; i < len; i += 10) {
      const index = i / 10;
      statistics[index] = [];
      statistics[index][0] = values[i]; // IP
      // Don't care about i+1
      statistics[index][8] = values[i + 2]; // total pkts up
      statistics[index][7] = values[i + 3]; // total pkts down
      statistics[index][6] = values[i + 4]; // total bytes up
      statistics[index][5] = values[i + 5]; // total bytes down
      statistics[index][4] = values[i + 6]; // current pkts up
      statistics[index][3] = values[i + 7]; // current pkts down
      statistics[index][2] = values[i + 8]; // current up
      statistics[index][1] = values[i + 9]; // current down
    }
    trafficStats = statistics;
  });
}

exports.getStatistics = function () {
  return { traffic: trafficStats, clients: hostnames, throttled };
};

init();
